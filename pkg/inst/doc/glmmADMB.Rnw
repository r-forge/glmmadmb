% \VignetteIndexEntry{basic examples of glmmADMB usage}
\documentclass{article}
%\usepackage{lineno}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[usenames]{color}
\usepackage[american]{babel}
\newcommand{\R}{{\sf R}}
\newcommand{\Splus}{{\sf S-PLUS}}
%\newcommand{\fixme}[1]{\textbf{FIXME: #1}}
\newcommand{\fixme}[1]{\color{red} #1 \color{black}}
\usepackage{url}
\usepackage{hyperref}
\usepackage{alltt}
\newcommand{\code}[1]{{\tt #1}}
\usepackage{fancyvrb}
\VerbatimFootnotes
\bibliographystyle{plain}

\title{Getting started with the \code{glmmADMB} package}
\author{Ben Bolker, Hans Skaug, Arni Magnusson, Anders Nielsen}
\date{\today}
\begin{document}
\maketitle

%\linenumbers

\SweaveOpts{eps=TRUE,pdf=TRUE}
<<setopts,echo=FALSE>>=
Rver <- paste(R.version$major,R.version$minor,sep=".")
options(continue=" ")
##if (require(cacheSweave)) {
##  setCacheDir("glmmADMB_vignette")
##}
@ 
<<graphopts,echo=FALSE>>=
library(ggplot2)
theme_update(theme_bw())
zmargin <- opts(panel.margin=unit(0,"lines"))
@ 


\section{Introduction/quick start}

\code{glmmADMB} is a package, built on 
the open source
\href{http://admb-project.org}{AD Model Builder}
nonlinear fitting engine, for fitting generalized
linear mixed models and extensions.

\begin{itemize}
  \item response distributions: Poisson, binomial, negative binomial (NB1 and NB2 parameterizations), Gamma, Beta, truncated Poisson and negative binomial; Gaussian; logistic
  \item link functions: log, logit, probit, complementary log-log (\code{"cloglog"}), inverse, identity
  \item zero-inflation (models with a constant zero-inflation value only); hurdle models via truncated Poisson/NB
  \item single or multiple (nested or crossed) random effects
  \item offsets
  \item post-fit MCMC chain for characterizing uncertainty
\end{itemize}

As of version 0.6.5, the package has been greatly revised to
allow a wider range of response and link functions and to allow
models with multiple random effects.  For now, the resulting package
is slower than the old (single-random-effect version), but we hope
to increase its speed in the future.

In order to use \code{glmmADMB} effectively you should already
be reasonably familiar with generalized linear mixed models
(GLMMs), which in turn requires familiarity with (i) generalized
linear models (e.g. the special cases of logistic, binomial,
and Poisson regression) and (ii) `modern' mixed models (those
working via maximization of the marginal likelihood rather
than by manipulating sums of squares).

In order to fit a model in \code{glmmADMB} you need to:
\begin{itemize}
\item specify a model for the fixed effects, in the standard
  R (Wilkinson-Rogers) formula notation (see \code{?formula}
  or Section 11.1 of the \href{http://cran.r-project.org/doc/manuals/R-intro.pdf}{Introduction to R}. 
  Formulae can also include \emph{offsets}.
\item specify a model for the random effects, in the notation
  that is common to the \code{nlme} and \code{lme4} packages.
  Random effects are specified as \code{e|g}, where \code{e}
  is an effect and \code{g} is a grouping factor (which must
  be a factor variable, or a nesting of/interaction among factor variables).
  For example, the formula would be \code{1|block} for a random-intercept model
  or \code{time|block} for a model with random variation in slopes
  through time across groups specified by \code{block}. A model
  of nested random effects (block within site) would be
  \code{1|site/block}; a model of crossed random effects
  (block and year) would be \code{(1|block)+(1|year)}.
  
  Random effects can be specified
  either in a separate \code{random} argument (as in \code{nlme})
  or as part of the model formula (as in \code{lme4}).
\item choose the error distribution by specifying the family 
  (as a string: e.g. \code{"poisson"}  or \code{"binomial"})
\item specify a link function (as a string: e.g. 
  \code{"logit"} or \code{"log"}.
\item optionally specify that zero-inflation is present
  \code{zeroInflation=TRUE}. In the current version, zero-inflation
  can only be specified as a single constant term across the
  entire model --- i.e. it cannot vary across groups or
  with covariates.
\end{itemize}
    
\section{Owls data}

These data, taken from \cite{zuur_mixed_2009} and ultimately
from \cite{roulinbersier_2007}, quantify
the number of negotiations among owlets (owl chicks)
in different nests \emph{prior} to the arrival
of a provisioning parent as a function of food treatment
(deprived or satiated), the sex of the parent, and
arrival time.  The total number of calls from the
nest is recorded, along with the total brood size, which
is used as an offset to allow the use of a Poisson response.

Since the same nests are measured repeatedly, the nest is used as
a random effect.
The model can be expressed as a zero-inflated generalized
linear mixed model (ZIGLMM).

First we draw some pictures (Figures~\ref{fig:owl1}, \ref{fig:owl2}).

Load the \code{glmmADMB} package to get access to the \code{Owls}
data set; load the \code{ggplot2} graphics package.
<<>>=
library(glmmADMB)
library(ggplot2)
@ 

Various small manipulations of the data set:
(1) reorder nests by mean negotiations per chick, for plotting
purposes; (2) add log brood size variable (for offset);
(3) rename response variable.
<<>>=
Owls <- transform(Owls,
  Nest=reorder(Nest,NegPerChick),
  logBroodSize=log(BroodSize),
  NCalls=SiblingNegotiation)
@ 

\begin{figure}
\setkeys{Gin}{width=\textwidth}
<<owlplot1,fig=TRUE,echo=FALSE>>=
G0 <- ggplot(Owls,aes(x=reorder(Nest,NegPerChick),
                      y=NegPerChick))+
  xlab("Nest")+ylab("Negotiations per chick")+coord_flip()+
  facet_grid(FoodTreatment~SexParent)
print(G0+stat_sum(aes(size=..n..),alpha=0.5)+zmargin+
      scale_size_continuous(name="# obs",
                            breaks=seq(1,9,by=2)))
@ 
\caption{Basic view of owl data (arrival time not shown).}
\label{fig:owl1}
\end{figure}

\begin{figure}
<<owlplot2,fig=TRUE,echo=FALSE>>=
G1 <- ggplot(Owls,aes(x=ArrivalTime,
                      y=NegPerChick,colour=FoodTreatment,
                      linetype=SexParent,
                      shape=SexParent))
print(G1+stat_sum(aes(size=factor(..n..)),alpha=0.5)+geom_smooth()+
      ## facet_grid(.~SexParent)+zmargin+
      labs(x="Arrival time",y="Negotiations per chick")+
      scale_size_discrete(name="# obs",
                          breaks=c("1","2")))
@ 
\caption{Basic view of owl data, \#2 (nest identity not shown)}
\label{fig:owl2}
\end{figure}

Now fit some models:

The basic \code{glmmadmb} fit --- a zero-inflated Poisson model.
<<time1,echo=FALSE,cache=TRUE>>=
gt1 <- system.time(glmmadmb(NCalls~(FoodTreatment+ArrivalTime)*SexParent+
                                     offset(logBroodSize)+(1|Nest),
                                     data=Owls,
                                     zeroInflation=TRUE,
                                     family="poisson"))
@ 
<<glmmadmbfit,cache=TRUE>>=
fit_zipoiss <- glmmadmb(NCalls~(FoodTreatment+ArrivalTime)*SexParent+
                                     offset(logBroodSize)+(1|Nest),
                                     data=Owls,
                                     zeroInflation=TRUE,
                                     family="poisson")
@

<<>>=
summary(fit_zipoiss)
@ 

The \code{coefplot2} package knows about \code{glmmadmb} fits:

<<coefplotmg1,fig=TRUE,width=8>>=
library(coefplot2)
coefplot2(fit_zipoiss)
@ 

We can also try a standard zero-inflated negative binomial model;
the default is the ``NB2'' parameterization (variance = $\mu(1+\mu/k)$).
<<glmmadmbnbinomfit,cache=TRUE>>=
fit_zinbinom <- glmmadmb(NCalls~(FoodTreatment+ArrivalTime)*SexParent+
                  offset(logBroodSize)+(1|Nest),
                  data=Owls,
                  zeroInflation=TRUE,
                  family="nbinom")
@

Alternatively, use an ``NB1'' fit (variance = $\phi \mu$).
<<glmmadmbnbinom1fit,cache=TRUE>>=
fit_zinbinom1 <- glmmadmb(NCalls~(FoodTreatment+ArrivalTime)*SexParent+
                                     offset(logBroodSize)+(1|Nest),
                                     data=Owls,
                                     zeroInflation=TRUE,
                                     family="nbinom1")
@ 

Relax the assumption that total number of calls is strictly proportional
to brood size (i.e. using log(brood size) as an offset):
<<glmmadmbnbinom1vfit,cache=TRUE>>=
fit_zinbinom1_bs <- glmmadmb(NCalls~(FoodTreatment+ArrivalTime)*SexParent+
                                     BroodSize+(1|Nest),
                                     data=Owls,
                                     zeroInflation=TRUE,
                                     family="nbinom1")
@ 

Every change we have made so far improves the fit --- changing distributions
improves it enormously, while changing the role of brood size makes only
a modest (-1 AIC unit) difference:
<<>>=
library(bbmle)
AICtab(fit_zipoiss,fit_zinbinom,fit_zinbinom1,fit_zinbinom1_bs)
@ 

Compare the parameter estimates:
<<cplot2,fig=TRUE>>=
vn <- c("food","arrivaltime","sex","food:sex","arrival:sex","broodsize")
coefplot2(list(ZIP=fit_zipoiss,
               ZINB=fit_zinbinom,
               ZINB1=fit_zinbinom1,
               ZINB1_brood=fit_zinbinom1_bs),
          varnames=vn,
          legend=TRUE)
@ 

\subsection{Hurdle models}

In contrast to zero-inflated models, hurdle models treat zero-count
and non-zero outcomes as two completely separate categories, rather than
treating the zero-count outcomes as a mixture of structural and
sampling zeros.

As of version 0.6.7.1, \code{glmmADMB} includes truncated
Poisson and negative binomial familes and hence can fit hurdle models.
The two parts of the model have to be fitted separately, however.
First we fit a truncated distribution to the non-zero outcomes:

<<glmmadmbnbinomhfit,cache=TRUE>>=
fit_hnbinom1 <- glmmadmb(NCalls~(FoodTreatment+ArrivalTime)*SexParent+
                         BroodSize+(1|Nest),
                         data=subset(Owls,NCalls>0),
                         family="truncnbinom1")
@ 

Then we fit a model to the binary part of the data (zero vs. non-zero).
In this case, I started by fitting a simple (intercept-only) model
with intercept-level random effects only.  This comes a bit closer
to matching the previous (zero-inflation) models, which treated zero-inflation
as a single constant level across the entire data set (in fact,
leaving out the random effects and just using 
\verb+glmmADMB(nz~1,data=Owls,family="binomial")+, or 
\verb+glm(nz~1,data=Owls,family="binomial")+, would
be an even closer match).
I then fitted a more complex binary model --- this is
all a matter of judgment about how complex a model it's worth
trying to fit to a given data set --- but it does look as though
the zero-inflation varies with arrival time and satiation.

<<glmmadmbcfit,cache=TRUE>>=
Owls$nz <- as.numeric(Owls$NCalls>0)
fit_count <- glmmadmb(nz~1+(1|Nest),
                         data=Owls,
                         family="binomial")
fit_ccount <- glmmadmb(nz~(FoodTreatment+ArrivalTime)*SexParent+(1|Nest),
                       data=Owls,
                       family="binomial")
AICtab(fit_count,fit_ccount)
summary(fit_ccount)
@ 

\subsection{MCMC fitting}

AD Model Builder has the capability to run a \emph{post hoc} Markov chain to
assess variability --- that is, it uses the MLE as a starting point and the
estimated sampling distribution (variance-covariance matrix) of the parameters
as a candidate distribution, and ``jumps around'' the parameter space in
a consistent way (Metropolis-Hastings?) to generate a series of samples
from a posterior distribution of the parameter distribution (assuming
flat priors: please see the ADMB documentation, or \cite{Bolker2008}, for
more details).

<<echo=FALSE>>=
load("owls_mcmcbatch.RData")
@ 

This is very convenient, but tends to be a bit slow.  In the example below,
I ran a chain of 50,000 MCMC iterations --- on examination, the default
chain of 1000 iterations was much too short --- which took about
\Sexpr{round(sum(mcmctime[4:5])/(60*60),2)} hours on a modern (2011) laptop.

<<eval=FALSE>>=
fit_zinbinom1_bs_mcmc <- glmmadmb(NCalls~(FoodTreatment+ArrivalTime)*SexParent+
                                     BroodSize+(1|Nest),
                                     data=Owls,
                                     zeroInflation=TRUE,
                                     family="nbinom1",
                                  mcmc=TRUE,
                                  mcmc.opts=mcmcControl(mcmc=50000))
@ 


Convert the MCMC chain to an \code{mcmc} object which the 
\code{coda} package can handle:

<<>>=
library(coda)
m <- as.mcmc(fit_zinbinom1_bs_mcmc$mcmc)
@ 

Look at the trace plots.

<<fig=TRUE>>=
library(scapeMCMC)
plotTrace(m)
@ 

The Geweke diagnostic gives $Z$ scores for each
variable for a comparison
between (by default) the first 10\% and last 50\% of
the chain
<<>>=
(gg <- geweke.diag(m))
summary(2*pnorm(abs(gg$z),lower.tail=FALSE))
@ 

%% would make this a footnote but run into problems compiling LaTeX
%% version ... "keyval error: 1 undefined"

The most frequently used diagnostic, Gelman-Rubin
(\code{gelman.diag}), requires multiple chains. The full set of
diagnostic functions available in \code{coda} is:
<<echo=FALSE>>=
a1 <- apropos(".diag$",where=TRUE)
print(unname(a1[names(a1)==which(search()=="package:coda")]),
      quote=FALSE)
@ 


\code{effectiveSize} gives the effective length of the
chain for each variable, i.e. the number of samples
corrected for autocorrelation:
<<>>=
range(effectiveSize(m))
@ 

\code{HPDinterval} gives the highest posterior density
(credible interval):
<<>>=
head(HPDinterval(m))
@ 

You might prefer inferences based on the quantiles instead:
<<>>=
head(t(apply(m,2,quantile,c(0.025,0.975))))
@ 

You can also look at density plots or pairwise scatterplots
(``splom'' in \code{lattice} and
\code{scapeMCMC}, for \textbf{S}catter\textbf{plo}t \textbf{m}atrices),
although these are not particularly useful for this large a set
of parameters:
<<eval=FALSE>>=
plotDens(m)
plotSplom(m,pch=".")  
@ 

The MCMC output in \code{glmmADMB} is currently in a very raw form --- in particular, the internal names and variants of the parameters are used:
\begin{description}
  \item[pz] zero-inflation parameter
  \item[beta] fixed-effect parameter estimates: \textbf{note} that these
    are the versions of the parameters fitted internally, 
    using an orthogonalized version of the original design matrix,
    not the original coefficients (if this means nothing to you, as it might well, just accept that these are transformed versions of the parameters).
\item[tmpL] variance-covariance parameters
\item[log\_alpha] log of overdispersion/scale parameter
\item[u] random effects (unscaled)
\end{description}
 If you need to use the MCMC output and can't figure out how, please contact the maintainers and encourage them to work on them some more  (!)
 
\section{Other information}
The standard set of accessors is available:
\begin{description}
  \item[\code{coef}] extract (fixed-effect) coefficients
  \item[\code{fixef}] a synonym for \code{coef}, for consistency
    with \code{nlme}/\code{lme4}
  \item[\code{ranef}] extract random effect coefficients
    (``BLUPs'' or ``conditional modes'')
  \item[\code{residuals}] extract (Pearson) residuals
  \item[\code{fitted}] fitted values
  \item[\code{predict}] predicted values
    (\emph{based only on fixed effects, not on random effects}),
    possibly with standard errors (\emph{based only on 
      uncertainty of fixed effects}), possibly for new data
  \item[\code{logLik}] extract log-likelihood
  \item[\code{AIC}] extract AIC
  \item[\code{summary}] print summary
  \item[\code{stdEr}] extract standard errors of coefficients
  \item[\code{vcov}] extract estimated variance-covariance matrix of coefficients
  \item[\code{VarCorr}] extract variance-covariance matrices of random effects
  \item[\code{confint}] extract confidence intervals of fixed-effect coefficients
\end{description} 

\section{To do/road map}
\subsection{Vignette}
\begin{itemize}
  \item More examples
  \item Show how to specify starting values
  \item fix MCMC!
  \item General troubleshooting (extra arguments, running outside R)
  \item basic intro to \code{R2admb}?
  \item (appendix?) document details of TPL file -- robustness hacks, etc.
\end{itemize}
\subsection{Code}
\begin{itemize}
\item Speed improvement by identifying special cases?
\item Spatial models?
\item Additional flexibility:
  \begin{itemize}
  \item Allow model specification for zero-inflation
  \item Allow model specification for shape parameter
  \item More complex variance models (see AS-REML/MCMCglmm for interface/syntax ideas)
  \end{itemize}
  \item Improve \code{predict} method: allow prediction based on REs
  \item \code{simulate} method
\end{itemize}


%%  AFTER HERE: stuff that's not really finished
%Load data on epilepsy from the \code{MASS} package
%(the \code{glmmADMB} package contains a copy of
%this information as well).

<<loaddat,echo=FALSE,eval=FALSE>>=
library(MASS)
epil2 <- transform(epil,
                   Base=log(base/4),
                   Age=log(age),
                   Visit=scale(period,center=TRUE,scale=5),
                   subject=factor(subject))
@ 

<<echo=FALSE,eval=FALSE>>=
print(ggplot(epil2,aes(x=base,y=log(1+y),colour=trt))+
       stat_sum(aes(size=factor(..n..)),alpha=0.5)+
  facet_wrap(~period)+
  scale_x_log10()+geom_smooth()+zspace)
@ 

<<fit1,echo=FALSE,eval=FALSE>>=
fm <- glmmadmb(y~Base*trt+Age+Visit+(Visit|subject),
                data=epil2, family="nbinom")
@ 

<<fit2,echo=FALSE,eval=FALSE>>=
fm2 <- glmmadmb(y~Base*trt+Age+Visit+(1|subject),
                data=epil2, family="nbinom")

@ 

<<echo=FALSE,eval=FALSE>>=
glm0 <- glm(y ~ lbase*trt + lage + V4, family = poisson,
            data = epil)
@ 
<<echo=FALSE,eval=FALSE>>=
## stuff taken from help("epil",package="MASS")
## figure out what's going on here?  work this
## up into a reasonable comparison ...

## basic GLM analysis
summary(glm(y ~ lbase*trt + lage + V4, family = poisson,
            data = epil), cor = FALSE)
epil3 <- subset(epil,period == 1)
epil3["period"] <- rep(0, 59); epil3["y"] <- epil3["base"]
epil["time"] <- 1; epil3["time"] <- 4
epil3 <- rbind(epil, epil3)
epil3$pred <- unclass(epil3$trt) * (epil3$period > 0)
epil3$subject <- factor(epil3$subject)
epil3 <- aggregate(epil3, list(epil3$subject, epil3$period > 0),
                   function(x) if(is.numeric(x)) sum(x) else x[1])
epil3$pred <- factor(epil3$pred,
                     labels = c("base", "placebo", "drug"))

contrasts(epil3$pred) <- structure(contr.sdif(3),
                                   dimnames = list(NULL, 
                                     c("placebo-base", "drug-placebo")))
summary(glm(y ~ pred + factor(subject) + offset(log(time)),
            family = poisson, data = epil3), cor = FALSE)

summary(glmmPQL(y ~ lbase*trt + lage + V4,
                random = ~ 1 | subject,
                family = poisson, data = epil))
summary(glmmPQL(y ~ pred, random = ~1 | subject,
                family = poisson, data = epil3))
     
@ 
\bibliography{glmmadmb}
\end{document}
